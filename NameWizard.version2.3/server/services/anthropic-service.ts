import Anthropic from '@anthropic-ai/sdk';

// Define a simple interface for text content blocks
interface ContentBlockText {
  type: 'text';
  text: string;
}

// Check if ANTHROPIC_API_KEY is available in environment variables
const hasAnthropicKey = !!process.env.ANTHROPIC_API_KEY;

// Initialize Anthropic client if API key is available
const anthropic = hasAnthropicKey 
  ? new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    }) 
  : null;

// Helper function to generate a mock response when no API key is available
const generateMockResponse = <T>(responseData: T): Promise<T> => {
  return new Promise(resolve => {
    // Add a small delay to simulate API call
    setTimeout(() => {
      resolve(responseData);
    }, 800);
  });
};

// Helper function to safely extract text from content blocks
const extractTextFromContent = (messageContent: Array<any>): string => {
  if (messageContent.length === 0) return '{}';
  
  const firstContent = messageContent[0];
  if ('text' in firstContent) {
    return firstContent.text || '{}';
  }
  
  console.log('Response content format unexpected:', messageContent);
  return '{}';
};

/**
 * Generate name suggestions based on file content using Claude
 */
export async function generateNameSuggestions(data: { 
  fileName: string;
  fileType: string;
  content?: string;
  metadata?: Record<string, any>;
}): Promise<{
  suggestions: string[];
  reasoning: string;
}> {
  if (!anthropic) {
    // Return mock data if Anthropic client is not available
    return generateMockResponse({
      suggestions: [
        `Claude_${data.fileType === 'image' ? 'Photo' : 'Document'}_${new Date().toISOString().split('T')[0]}`,
        `Claude_${data.fileName.split('.')[0]}_revised`,
        `Claude_${data.fileType === 'image' ? 'Image' : 'File'}_${Math.floor(Math.random() * 1000)}`,
        `Claude_${data.fileType === 'image' ? 'Picture' : 'Doc'}_${new Date().toLocaleTimeString().replace(/:/g, '')}`,
      ],
      reasoning: "These suggestions are generated by Claude based on the file type and current date/time."
    });
  }

  try {
    // Prepare prompt for the Claude model
    const userPrompt = `I need you to suggest better names for this file: "${data.fileName}".
    File type: ${data.fileType}
    ${data.content ? `File content preview: ${data.content.substring(0, 500)}...` : ''}
    ${data.metadata ? `File metadata: ${JSON.stringify(data.metadata)}` : ''}
    
    Please provide 4 appropriate name suggestions that are descriptive and well-organized.
    Return your response as a JSON object with the following format:
    {
      "suggestions": ["suggestion1", "suggestion2", "suggestion3", "suggestion4"],
      "reasoning": "A brief explanation of your naming approach"
    }`;

    // Call the Claude API
    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20240620",
      max_tokens: 1024,
      system: "You are an expert file naming assistant that suggests descriptive, organized filenames based on content analysis. Always return a JSON response with helpful name suggestions.",
      messages: [
        { role: 'user', content: userPrompt }
      ],
    });

    // Extract and parse text content
    const responseText = extractTextFromContent(message.content);
    
    try {
      return JSON.parse(responseText);
    } catch (parseError) {
      console.error("Error parsing Anthropic response:", parseError);
      // If parsing fails, extract suggestions from text response
      const suggestions = responseText.match(/["']([^"']+)["']/g)?.map((s: string) => s.replace(/["']/g, '')) || 
        [`Claude_${data.fileName.split('.')[0]}_1`, 
         `Claude_${data.fileName.split('.')[0]}_2`,
         `Claude_${data.fileName.split('.')[0]}_3`,
         `Claude_${data.fileName.split('.')[0]}_4`];
      
      return {
        suggestions: suggestions.slice(0, 4),
        reasoning: "Generated name suggestions based on file analysis."
      };
    }
  } catch (error) {
    console.error("Error generating name suggestions with Claude:", error);
    throw new Error("Failed to generate name suggestions with Claude");
  }
}

/**
 * Analyze content and suggest categories or organization using Claude
 */
export async function analyzeContent(data: {
  files: Array<{
    fileName: string;
    fileType: string;
    content?: string;
    metadata?: Record<string, any>;
  }>
}): Promise<{
  categories: Array<{
    name: string;
    files: string[];
  }>;
  reasoning: string;
}> {
  if (!anthropic) {
    // Return mock data if Anthropic client is not available
    return generateMockResponse({
      categories: [
        { name: "Claude - Documents", files: data.files.filter(f => f.fileType.includes('document') || f.fileType.includes('pdf')).map(f => f.fileName) },
        { name: "Claude - Images", files: data.files.filter(f => f.fileType.includes('image')).map(f => f.fileName) },
        { name: "Claude - Other", files: data.files.filter(f => !f.fileType.includes('document') && !f.fileType.includes('pdf') && !f.fileType.includes('image')).map(f => f.fileName) }
      ],
      reasoning: "Files have been grouped by Claude based on their file types."
    });
  }

  try {
    const fileInfoText = data.files.map(file => {
      return `File: ${file.fileName}, Type: ${file.fileType}${file.content ? `, Content preview: ${file.content.substring(0, 200)}...` : ''}`;
    }).join("\n");

    const userPrompt = `I need you to analyze these files and suggest logical categories for organizing them:
    ${fileInfoText}
    
    Please suggest category names and assign each file to the most appropriate category.
    Return your response as a JSON object with the following format:
    {
      "categories": [
        {
          "name": "Category1",
          "files": ["filename1", "filename2"]
        },
        {
          "name": "Category2",
          "files": ["filename3", "filename4"]
        }
      ],
      "reasoning": "A brief explanation of your categorization approach"
    }`;

    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20240620",
      max_tokens: 1024,
      system: "You are an expert file organization assistant that suggests logical categories for files based on content analysis. Always return a JSON response.",
      messages: [
        { role: 'user', content: userPrompt }
      ],
    });

    // Extract and parse text content
    const responseText = extractTextFromContent(message.content);
    return JSON.parse(responseText);
  } catch (error) {
    console.error("Error analyzing content with Claude:", error);
    throw new Error("Failed to analyze content with Claude");
  }
}

/**
 * Format file names to a specific case style using Claude
 */
export async function formatCase(names: string[], caseType: string): Promise<string[]> {
  if (!anthropic) {
    // Return mock data for different case formats
    switch(caseType) {
      case 'camelCase':
        return names.map(name => name.replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => 
          index === 0 ? word.toLowerCase() : word.toUpperCase()).replace(/\s+/g, ''));
      case 'snake_case':
        return names.map(name => name.toLowerCase().replace(/\s+/g, '_'));
      case 'kebab-case':
        return names.map(name => name.toLowerCase().replace(/\s+/g, '-'));
      case 'PascalCase':
        return names.map(name => name.replace(/(?:^\w|[A-Z]|\b\w)/g, (word) => 
          word.toUpperCase()).replace(/\s+/g, ''));
      default:
        return names;
    }
  }

  try {
    const userPrompt = `I need you to format these file names to ${caseType}:
    ${names.join('\n')}
    
    Please convert each name and return only an array of the formatted names, nothing else.`;

    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20240620",
      max_tokens: 1024,
      system: "You are an expert in formatting filenames. Format the provided filenames into the requested case style and return them as a simple array, one per line.",
      messages: [
        { role: 'user', content: userPrompt }
      ],
    });

    // Extract text content
    const responseText = extractTextFromContent(message.content);
    if (!responseText) return names;
    
    // Clean up any extra text and extract just the formatted names
    const formattedNames = responseText.match(/[^\s"',\[\]]+/g)?.filter((name: string) => name.length > 1) || names;
    
    return formattedNames;
  } catch (error) {
    console.error("Error formatting case with Claude:", error);
    throw new Error("Failed to format case with Claude");
  }
}

/**
 * Extract metadata from file name or content using Claude
 */
export async function extractMetadata(fileName: string, content: string): Promise<{
  metadata: Record<string, any>;
  suggestedFilename: string;
}> {
  if (!anthropic) {
    // Generate mock metadata
    const date = new Date().toISOString().split('T')[0];
    const fileType = fileName.split('.').pop()?.toLowerCase() || 'unknown';
    let mockMetadata: Record<string, any> = {
      date: date,
      fileType: fileType,
      processor: "Claude",
      estimatedSize: `${Math.floor(Math.random() * 10) + 1} MB`,
    };
    
    if (fileType === 'jpg' || fileType === 'png') {
      mockMetadata = {
        ...mockMetadata,
        resolution: '1920x1080',
        colorSpace: 'RGB',
        deviceMake: 'Generic Camera',
      };
    } else if (fileType === 'pdf' || fileType === 'docx') {
      mockMetadata = {
        ...mockMetadata,
        pageCount: Math.floor(Math.random() * 20) + 1,
        author: 'John Doe',
        created: date,
        modified: date,
      };
    }
    
    return generateMockResponse({
      metadata: mockMetadata,
      suggestedFilename: `Claude_${date}_${fileName.split('.')[0]}.${fileType}`
    });
  }

  try {
    const userPrompt = `I need you to extract relevant metadata from this file:
    Filename: ${fileName}
    Content preview: ${content.substring(0, 500)}...
    
    Please analyze both the filename and content to extract useful metadata like:
    - Creation/modification dates
    - Authors or creators
    - Subject or topic
    - Categories
    - Any other relevant attributes
    
    Also suggest an improved filename based on the metadata.
    
    Return your response as a JSON object with the following format:
    {
      "metadata": {
        "key1": "value1",
        "key2": "value2"
      },
      "suggestedFilename": "improved-filename.ext"
    }`;

    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20240620",
      max_tokens: 1024,
      system: "You are an expert metadata extractor. Analyze file names and content to extract useful metadata and suggest improved filenames. Always return a JSON response.",
      messages: [
        { role: 'user', content: userPrompt }
      ],
    });

    // Extract and parse text content
    const responseText = extractTextFromContent(message.content);
    return JSON.parse(responseText);
  } catch (error) {
    console.error("Error extracting metadata with Claude:", error);
    throw new Error("Failed to extract metadata with Claude");
  }
}

/**
 * Organize files into folder structures using Claude
 */
export async function organizeFoldersWithClaude(files: Array<{
  fileName: string;
  fileType: string;
  content?: string;
  metadata?: Record<string, any>;
}>): Promise<{
  folders: Array<{
    name: string;
    files: string[];
  }>;
  summary: string;
}> {
  if (!anthropic) {
    // Generate mock folder organization
    const mockFolders: { name: string, files: string[] }[] = [
      { name: "Claude - Documents", files: [] },
      { name: "Claude - Images", files: [] },
      { name: "Claude - Spreadsheets", files: [] },
      { name: "Claude - Archives", files: [] },
      { name: "Claude - Other", files: [] }
    ];
    
    files.forEach(file => {
      const ext = file.fileName.split('.').pop()?.toLowerCase() || '';
      if (['docx', 'pdf', 'txt'].includes(ext)) {
        mockFolders[0].files.push(file.fileName);
      } else if (['jpg', 'png', 'gif'].includes(ext)) {
        mockFolders[1].files.push(file.fileName);
      } else if (['xlsx', 'csv'].includes(ext)) {
        mockFolders[2].files.push(file.fileName);
      } else if (['zip', 'rar', '7z'].includes(ext)) {
        mockFolders[3].files.push(file.fileName);
      } else {
        mockFolders[4].files.push(file.fileName);
      }
    });
    
    // Filter out empty folders
    const filteredFolders = mockFolders.filter(folder => folder.files.length > 0);
    
    return generateMockResponse({
      folders: filteredFolders,
      summary: `Organized ${files.length} files into ${filteredFolders.length} folders using Claude based on file types.`
    });
  }

  try {
    const fileInfoText = files.map(file => {
      return `File: ${file.fileName}, Type: ${file.fileType}${file.content ? `, Content preview: ${file.content.substring(0, 200)}...` : ''}`;
    }).join("\n");

    const userPrompt = `I need you to organize these files into a logical folder structure:
    ${fileInfoText}
    
    Please create a set of folders and assign each file to the most appropriate folder
    based on its content, type, and any other relevant attributes.
    
    Return your response as a JSON object with the following format:
    {
      "folders": [
        {
          "name": "FolderName",
          "files": ["filename1", "filename2"]
        }
      ],
      "summary": "Brief explanation of your organization approach"
    }`;

    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20240620",
      max_tokens: 1024,
      system: "You are an expert file organization assistant. Create a logical folder structure for files based on their content and type. Always return a JSON response.",
      messages: [
        { role: 'user', content: userPrompt }
      ],
    });

    // Extract and parse text content
    const responseText = extractTextFromContent(message.content);
    return JSON.parse(responseText);
  } catch (error) {
    console.error("Error organizing folders with Claude:", error);
    throw new Error("Failed to organize folders with Claude");
  }
}

/**
 * Detect duplicate files or potential conflicts using Claude
 */
export async function detectDuplicates(files: Array<{
  fileName: string;
  fileType: string;
  content?: string;
  size?: number;
  metadata?: Record<string, any>;
}>): Promise<{
  duplicateGroups: Array<{
    files: string[];
    recommendation: string;
  }>;
  summary: string;
}> {
  if (!anthropic) {
    // Return mock duplicate detection
    const duplicateGroups: Array<{files: string[], recommendation: string}> = [];
    const processedFiles = new Set<number>();
    
    for (let i = 0; i < files.length; i++) {
      if (processedFiles.has(i)) continue;
      
      const baseName = files[i].fileName.split('.')[0].toLowerCase();
      const similarFiles = [files[i].fileName];
      
      for (let j = i + 1; j < files.length; j++) {
        if (processedFiles.has(j)) continue;
        
        const currentName = files[j].fileName.split('.')[0].toLowerCase();
        if (currentName.includes(baseName) || baseName.includes(currentName) || 
            Math.abs(currentName.length - baseName.length) <= 3) {
          similarFiles.push(files[j].fileName);
          processedFiles.add(j);
        }
      }
      
      if (similarFiles.length > 1) {
        duplicateGroups.push({
          files: similarFiles,
          recommendation: `Claude found these files appear similar. Consider renaming to avoid confusion: ${baseName}_v1, ${baseName}_v2, etc.`
        });
      }
    }
    
    return generateMockResponse({
      duplicateGroups,
      summary: `Claude found ${duplicateGroups.length} potential duplicate groups among ${files.length} files.`
    });
  }

  try {
    const fileInfoText = files.map(file => {
      return `File: ${file.fileName}, Type: ${file.fileType}${file.size ? `, Size: ${file.size} bytes` : ''}${file.content ? `, Content preview: ${file.content.substring(0, 100)}...` : ''}`;
    }).join("\n");

    const userPrompt = `I need you to analyze these files and identify potential duplicates or naming conflicts:
    ${fileInfoText}
    
    Please identify groups of files that might be duplicates or have confusing similar names, 
    and suggest unique naming strategies for each group.
    
    Return your response as a JSON object with the following format:
    {
      "duplicateGroups": [
        {
          "files": ["filename1", "filename2"],
          "recommendation": "Recommendation for how to rename these files uniquely"
        }
      ],
      "summary": "Brief summary of your analysis"
    }`;

    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20240620",
      max_tokens: 1024,
      system: "You are an expert in detecting duplicate files and naming conflicts. Identify potential duplicates and suggest clear naming strategies. Always return a JSON response.",
      messages: [
        { role: 'user', content: userPrompt }
      ],
    });

    // Extract and parse text content
    const responseText = extractTextFromContent(message.content);
    return JSON.parse(responseText);
  } catch (error) {
    console.error("Error detecting duplicates with Claude:", error);
    throw new Error("Failed to detect duplicates with Claude");
  }
}